### Proyecto: decide-part-pantoja-2

**Grupo 1**  
**Curso Escolar:** 2023/2024  
**Asignatura:** Evolución y Gestión de la Configuración

---

#### Miembros del Equipo y Niveles de Implicación:

1. **Apellidos, Nombre:** Maqueda Acal, Antonio  
   Implicación: [10]

2. **Apellidos, Nombre:** Merida Bascon, Raul Hernan  
   Implicación: [10]

3. **Apellidos, Nombre:** Pino Mateo, Pablo  
   Implicación: [10]

4. **Apellidos, Nombre:** Ribas Luna, Gonzalo  
   Implicación: [10]

5. **Apellidos, Nombre:** Somoza Sierra, Andres Jesus  
   Implicación: [10]

6. **Apellidos, Nombre:** Stefan Bogdan  
   Implicación: [8]

---

#### Enlaces de Interés:

- [Repositorio de Código](https://github.com/part-pantoja/decide)
- [Sistema Desplegado](https://decidepantoja.pythonanywhere.com)
---

| Miembro del equipo           | Horas | Commits | LoC | Test | Issues | Incremento           |
|------------------------------|-------|---------|-----|------|--------|----------------------|
| Maqueda Acal, Antonio        | +25    | https://github.com/part-pantoja/decide/blob/develop/doc/Commits%20main%20Git%20Fame(No%20recoge%20todos).jpeg      | https://github.com/part-pantoja/decide/blob/develop/doc/Lineas%20Antonio%20Maqueda.jpeg  | 6   | 6     | Votación que permite crear una pregunta con los valores predeterminados Si y No.    |
| Merida Bascon, Raul Hernan   | +25    | https://github.com/part-pantoja/decide/blob/develop/doc/Commits%20main%20Git%20Fame(No%20recoge%20todos).jpeg      | https://github.com/part-pantoja/decide/blob/develop/doc/Lineas%20Raul.jpeg  | 6   | 6     | Votación con multiples preguntas simples.    |
| Pino Mateo, Pablo            | +25    | https://github.com/part-pantoja/decide/blob/develop/doc/Commits%20main%20Git%20Fame(No%20recoge%20todos).jpeg      | https://github.com/part-pantoja/decide/blob/develop/doc/Lineas%20Pablo.jpeg  | 6   | 8     | Votación que permite ordenar las respuestas según la preferencia del usuario.    |
| Ribas Luna, Gonzalo          | +25    | https://github.com/part-pantoja/decide/blob/develop/doc/Commits%20main%20Git%20Fame(No%20recoge%20todos).jpeg      | https://github.com/part-pantoja/decide/blob/develop/doc/Lineas%20Gonri.jpeg  | 6   | 6     | Votación que el creador asigna un número de puntos a repartir entre las opciones para que el votante los asigne. Y además otro tipo de votación en la que el votante puede marcar más de una opción.    |
| Somoza Sierra, Andres Jesus  | +25    | https://github.com/part-pantoja/decide/blob/develop/doc/Commits%20main%20Git%20Fame(No%20recoge%20todos).jpeg      | https://github.com/part-pantoja/decide/blob/develop/doc/Lineas%20Andres.jpeg  | 7   | 9     | Nueva pantalla en /booth donde se pueden comprobar las votaciones a las que el usuario tiene acceso, enseñando algunos datos de las mismas, dando opción de filtrarlas y dando acceso a la cabina. Implementada también una función que envía un correo electrónico al usuario con la respuesta a su solicitud de censo en una votación.    |
| Stefan Bogdan                | HH    | https://github.com/part-pantoja/decide/blob/develop/doc/Commits%20main%20Git%20Fame(No%20recoge%20todos).jpeg      | YY  | ZZ   | II     | Descripción breve    |
| **TOTAL**                    | +140   | +120     | 6538 | tZZ  | tII    | Descripción breve    |


# Integración con otros equipos

**Nombre-del-equipo: decide-part-pantoja-1**

Decidimos hacer un part con un equipo de 5 integrantes con los cuales teniamos relación anteriormente.


# Resumen ejecutivo

Decide es una plataforma de voto electrónico seguro que busca establecer garantías fundamentales, tales como la anonimicidad y el secreto del voto. Se presenta como un proyecto educativo centrado en el estudio de sistemas de votación, priorizando la simplicidad para facilitar la comprensión y extensibilidad del proyecto.

## Objetivo Principal

El objetivo principal de Decide es desarrollar e implementar diversas funcionalidades, ya sea incorporando nuevas características o mejorando las existentes. Más allá de la funcionalidad de la plataforma, el proyecto tiene una misión educativa ambiciosa.

## Misión Educativa

La misión educativa se enfoca en aprender y aplicar las mejores prácticas en:

- Gestión de incidencias durante el desarrollo.
- Administración del código fuente.
- Organización del equipo y gestión de los desarrolladores.
- Creación de casos de prueba exhaustivos.
- Implementación de integración continua para garantizar el acceso a versiones actualizadas del código.
- Estrategias de despliegue y entrega del proyecto.

## Estructura Organizativa

Aunque el proyecto no tiene límites o alcances específicos predefinidos, se ha adoptado una estructura organizativa para las tareas. La falta de límites concretos se compensa mediante la organización efectiva de las actividades para garantizar una implementación equitativa y comparativa de funcionalidades entre todos los participantes en el desarrollo.

Este enfoque flexible permite una adaptación continua a medida que se aprenden nuevas lecciones y se identifican oportunidades de mejora.

## Enfoque en Desarrollo

En el proceso de desarrollo, se presta especial atención a la gestión de incidencias. La aplicación de las mejores prácticas en este ámbito se convierte en un pilar esencial para abordar y resolver eficientemente los desafíos que puedan surgir durante el ciclo de vida del proyecto. Se establecen protocolos claros para identificar, documentar y solucionar incidencias, contribuyendo así a un desarrollo más robusto y libre de obstáculos.

La gestión eficaz del código fuente se considera un componente crítico para el éxito del proyecto. Se implementan prácticas de control de versiones que permiten a los desarrolladores colaborar de manera efectiva y mantener un historial transparente de los cambios realizados. La estructuración del código se realiza con un enfoque en la legibilidad y la extensibilidad, facilitando la comprensión y contribución de cada miembro del equipo.

La formación de un equipo cohesionado y motivado es esencial. La gestión de recursos humanos se lleva a cabo considerando las habilidades individuales, asignando tareas de manera equitativa y fomentando un entorno de colaboración. Se implementan prácticas ágiles para adaptarse a cambios y mejorar continuamente el rendimiento del equipo.

La aplicación se somete a pruebas exhaustivas mediante una cuidadosa planificación y ejecución de casos de prueba. Este enfoque garantiza una evaluación completa de la aplicación en diferentes escenarios, asegurando su robustez y confiabilidad.

La integración continua se convierte en una piedra angular para mantener la coherencia y la actualización del código. Se implementan sistemas automatizados que permiten a los desarrolladores acceder a versiones actualizadas del código, facilitando la colaboración y minimizando conflictos.

Se definen estrategias claras para el despliegue y la entrega del proyecto, garantizando una transición suave desde el desarrollo hasta la implementación. La planificación cuidadosa de estos procesos minimiza los tiempos de inactividad y asegura una experiencia fluida para los usuarios finales.

En resumen, Decide no solo se enfoca en ofrecer una plataforma de voto electrónico segura, sino que también se erige como un proyecto educativo ambicioso que abarca todos los aspectos cruciales del desarrollo de software y la gestión de proyectos. Su enfoque holístico busca no solo la eficacia en la implementación de funcionalidades, sino también la adopción y aplicación de las mejores prácticas en cada etapa del proceso. Este proyecto se presenta como un modelo de excelencia en la convergencia entre la teoría y la práctica en el desarrollo de software.

# Descripción del sistema

## I. Introducción
El sistema en cuestión es una aplicación de voto electrónico diseñada para facilitar y optimizar el proceso de votación en entornos diversos. La plataforma permite a un usuario, generalmente con los permisos correspondientes, crear preguntas de diferentes tipos para llevar a cabo votaciones. Además, dicho usuario tiene la capacidad de seleccionar y autorizar a otros participantes a emitir sus votos. Un aspecto crucial del sistema es que todos los votos son sometidos a un proceso de postprocesado que incluye la encriptación de los mismos.

El propósito fundamental de la aplicación es proporcionar una solución eficiente y segura para la gestión de votaciones, asegurando la integridad y confidencialidad de los resultados. Se busca simplificar el proceso de toma de decisiones mediante la automatización de las votaciones, eliminando la necesidad de métodos tradicionales y propiciando un entorno digital más accesible y eficaz.

El proyecto se desarrolla en el marco de la asignatura, partiendo de una base de código existente. Se utiliza el framework Django para la construcción de la aplicación, aprovechando su estructura robusta y su capacidad de desarrollo rápido. La base de datos utilizada es PostgreSQL, proporcionando una gestión eficiente de los datos relacionados con las votaciones.

El control de versiones se gestiona a través de GitHub, permitiendo un desarrollo colaborativo y un seguimiento detallado de los cambios realizados en el código. Asimismo, se prioriza la implementación de estándares de integración continua para asegurar la calidad del código y facilitar su despliegue eficiente.

## II. Descripción Funcional
### A. Objetivos Funcionales
-  Permitir la creación de diferentes tipos de votaciones.
-  Facilitar la participación de usuarios mediante una interfaz intuitiva.
-  Elaborar un sistema intuitivo de visualización de votos.
-  Facilitar la participación de los usuarios en votaciones.

### B. Funcionalidades Principales
- Con el propósito de ampliar las capacidades del sistema, se implementó la funcionalidad de crear diversos tipos de votaciones que no estaban presentes en el código original.
- Con el objetivo de mejorar la experiencia del usuario, se desarrolló una interfaz más intuitiva en comparación con la interfaz por defecto de Django. Ahora, los usuarios pueden unirse a una votación y emitir sus votos de manera más sencilla, utilizando botones en lugar de depender exclusivamente de URLs. Esta mejora busca reducir la fricción y hacer más accesible la participación en el proceso de votación.
- Dada la posibilidad de que el sistema maneje un gran volumen de votos, se implementó un sistema intuitivo de visualización. Los votos ahora pueden ser representados mediante gráficos de queso y de barras, proporcionando a los usuarios una forma rápida y clara de comprender los resultados de la votación. Esta adición no solo mejora la comprensión, sino que también facilita la toma de decisiones informadas.
- Con el objetivo de incentivar la participación de los usuarios, se introdujo la capacidad para que estos puedan solicitar unirse a una votación. Esta característica fomenta una mayor inclusión y permite a los usuarios expresar su interés en participar en procesos de votación específicos.


## III. Descripción Técnica
### A. Arquitectura del Sistema

El proyecto se estructura en diferentes módulos, cada uno desempeñando funciones específicas pero estrechamente interconectados para garantizar la coherencia y eficiencia del sistema. A continuación, se describen detalladamente los módulos del sistema:

#### 1. Modulo authentication

Este módulo se centra en la autenticación de usuarios y comprende funcionalidades como el registro, el inicio de sesión y características adicionales. Añadimos nuevas funciones, como el registro mediante Google, aunque esta característica tuvo que ser retirada del código final debido a inconvenientes con la clave de la API y problemas relacionados con la recepción de correos después del registro.

#### 2. Modulo booth

El módulo booth controla la parte visual de la votación. Es esencial para proporcionar una interfaz intuitiva y atractiva para que los usuarios participen en el proceso de votación.

#### 3. Modulo home

Introducimos el módulo home para mejorar la experiencia del usuario al añadir un nuevo inicio que no estaba presente en el código original. Este módulo, a través de un botón, se conecta directamente con el módulo booth, facilitando el acceso a la votación.

#### 4. Modulo census

El módulo census juega un papel fundamental al vincular a los usuarios con las votaciones. Para que un usuario pueda votar, debe estar incluido en el censo de esa votación. Se implementaron mejoras, como la capacidad de importar censos mediante documentos, para hacer más eficiente la gestión de los participantes en las votaciones.

#### 5. Modulo mixnet

Este módulo se encarga del proceso de mezcla de votos, garantizando la confidencialidad y la integridad de los resultados. Es esencial para preservar la privacidad de los votantes y evitar cualquier intento de identificación de votos individuales.

#### 6. Modulo postproc

El módulo postproc realiza el postprocesado de todos los votos. Dado que cada tipo de votación nuevo requiere un método de postprocesado distinto, se crearon métodos específicos para cada uno de ellos.

#### 7. Modulo request

Este módulo está directamente relacionado con los módulos user y census. Permite que los usuarios hagan solicitudes al administrador para ser añadidos al censo de una votación, mejorando la participación y la inclusión en los procesos de votación.

#### 8. Modulo visualizer

Después del recuento de votos, el módulo visualizer se encarga de mostrar las estadísticas de manera clara y comprensible para los usuarios, utilizando gráficos de barras y de queso, ofreciendo una visión detallada de los resultados.

#### 9. Modulo voting

El módulo voting es crucial para la acción de votar. Se han incorporado varios tipos de votaciones que se explicarán más detalladamente posteriormente, mejorando así la versatilidad y adaptabilidad del sistema a diferentes escenarios de votación.

Esta arquitectura modular no solo organiza de manera eficiente las funciones del sistema, sino que también permite una fácil expansión y mantenimiento, asegurando la coherencia y la eficacia en cada uno de los componentes.

### C. Tecnologías Utilizadas

- Django, el cual lo hemos utilizado porque ya estaba predefinido en la asignatura al ser un framework en el que es fácil añadir nuevas funcionalidades porque Django ya implementa muchas cosas que en otros frameworks se tardaría mas en implementar. 
- Python, porque se utiliza python para programar en django.
- Pynose, para asegurar la calidad del codigo.
- Selenium para automatizar las pruebas de aplicación web. 
- Codacy para hacer un análisis estático del código y asegurar una mantenibilidad y calidad del código.
- Github para controlar la gestión del código fuente.
- Github Actions para automatizar pruebas construccion y despliegue directamente desde el repositorio y asi mejorar la eficiencia del desarrollo y garantizar la estabilidad del código.
- Docker con el objetivo de facilitar la creación, distribución y ejecución de aplicaciones en contenedores.
- Vagrant para la creación y configuración de entornos de desarrollo virtualizados.
- PythonAnywhere para poder desplegar el proyecto en la nube.

## V. Cambios Desarrollados para el Proyecto

- Se han implementado los siguientes tipos de votaciones:
   - Votación de si o no: este nuevo tipo de votación permite crear una votación con una sola pregunta en la que las únicas opciones son sí o no.
   - Votación de multiple opción: en esta votación tenemos una pregunta en la que podremos marcar mas deuna opción.
   - Votación de asignación de puntos: en esta votación tendremos una cantidad de puntos declarada por el creador de la votación que el votante podrá repartir a su gusto por las diferentes opciones.
   - Votación de elección de orden: esta votación consistirá en ordenar las opciones por orden de preferencia. 
   - Votación de muchas preguntas: esta votación se podrá crear solo con preguntas de tipo simple, es decir no podremos asignar ninguna de la snuevas votaciones anteriores ya que los encriptados y postprocesados de las preguntas son diferentes. En esta votación podremos responder a vraias preguntas.
- Se ha implementado una página en /booth donde se muestran las votaciones en las que el usuario puede votar con un botón directo a la cabina de votación y donde se puede filtrar por todas las votaciones a las que el usuario tenga acceso, solo las que ya hayan empezado y por las que no hayan empezado aún. 
- Por último se ha implementado el envío de un correo electrónico como respuesta a la aceptación o denegación de una solicitud de un usuario para ser añadido a un censo.


# Proceso de Desarrollo en el Proyecto de Votaciones en Línea

El proceso de desarrollo en nuestro proyecto de votaciones en línea implica varias etapas clave que están intrínsecamente ligadas al ciclo de vida del desarrollo del software. A lo largo de este proceso, hemos empleado diversas herramientas que han facilitado y optimizado cada fase del desarrollo. A continuación, se presenta una descripción detallada de cada etapa seguida en el desarrollo del proyecto:

## 1. Diseño de Nuevas Funcionalidades:
En esta fase, nos hemos enfocado en identificar y diseñar las nuevas funcionalidades que mejorarán nuestro sistema de votación. Partiendo de esta premisa, decidimos que cada integrante propusiera una mejora funcional al sistema. Tras una reunión inicial se decidieron y definieron de manera muy básica los distintos implementos que realizaría cada integrante y fueron los siguientes:
- Creación de votaciones las cuales tengan asociada un pregunta de tipo Multiple Respuesta, en la que al realizar la votación pudieras marcar varias respuestas.
- Creación de votaciones las cuales tengan asociada un pregunta de tipo SiNo, en la que al realizar la votación las únicas posibles respuestas fueran Si o No.
- Creación de votaciones las cuales tengan asociada un pregunta de tipo Orden, en la que al realizar la votación pudieras ordenar las respuestas de la misma según tu criterio.
- Creación de votaciones las cuales tengan asociada un pregunta de tipo Puntos, en la que al realizar la votación pudieras asignar a cada respuesta un peso o unos puntos, repartiendo los que te permite la propia votación(si te da 10 puntos, pues tienes que repartirlos entre las distintas respuestas).
- Creación de votaciones las cuales tengan asociada varias preguntas de tipo Simple, en la que al realizar la votación puedas responder todas ellas.
- Creación de una interfaz para el usuario en la que pueda acceder a las distintas votaciones y si tiene el rol pertinente, poder crearlas, modificarlas, empezarlas...
- Traducción de la interfaz de usuario a varios idiomas.


## 2. Desarrollo de Funcionalidades:
Con el diseño en su lugar, nos sumergimos en la fase de desarrollo. Hemos utilizado herramientas de desarrollo colaborativas, usando Git como controlador de versiones y gestor de repositorios y GitHub como servicio de alojamiento en remoto para el trabajo conjunto entre los integrantes de nuestro equipo y los de la otra parte. Esto ha facilitado una programación eficiente en la que cada miembro tenia acceso al código actualizado de manera permanente. Así mismo para la organización de las ramas en el repositorio hemos seguido el modelo de GitFlow, organizando las ramas según su propósito, features si son para realizar funcionalidad, hotfix si son para realizar correcciones importantes en el código debido a algún bug, una rama main/master que se convertirá en la release(de ella saldrá) y una rama develop en la que ira actualizando el código en desarrollo de manera continua, CI.

## 3. Pruebas y Validación:
Una vez finalizada la implementación, dedicamos tiempo a llevar a cabo pruebas en las distintas funcionalidades creadas con un enfoque integral respaldado por herramientas como GitHub Actions. Hemos implementado un proceso de integración continua mediante GitHub Actions, automatizando pruebas para garantizar la estabilidad y la funcionalidad esperada del proyecto. Esto nos permitía asegurar que todo el código presente en la rama de desarrollo funcionaba de manera correcta, lo que nos aportaba seguridad en la combinación de las distintas funcionalidades.

Además de las pruebas automatizadas, hemos realizado pruebas manuales para evaluar la experiencia del usuario desde un punto de vista más gráfico, asegurándonos de que las nuevas funcionalidades se integren de manera coherente con las existentes. Este enfoque híbrido, combinando pruebas automatizadas y manuales, nos ha permitido obtener una visión completa de la calidad del software.

Para fortalecer nuestro proceso, hemos desplegado el proyecto en un servidor remoto utilizando PythonAnywhere mediante GitHub Actions, lo que nos permitía tener una aplicación funcionando y actualizada accesible por todos los miembros del equipo. Por último, configuración de nuestro repositorio en Codacy lo que nos permitía realizar un análisis de código estático de manera continua, identificando posibles problemas y proporcionando recomendaciones para mejorar la calidad del código, así como generándonos un informe de cobertura del proyecto.

Este proceso de integración continua nos permitía encontrar errores en el código de manera mas tempranas elaborando pruebas para cada funcionalidad y ejecutando las mismas de manera automática.

## 4. Preproducción:
La fase de preproducción ha sido esencial para identificar posibles problemas antes de lanzar la versión final del sistema. Hemos utilizado entornos de prueba que replican el entorno de producción y hemos realizado pruebas adicionales de carga y rendimiento para garantizar la eficiencia del sistema en situaciones de uso intensivo.

## 5. Producción:
Finalmente, hemos llevado nuestro proyecto a producción. Hemos utilizado herramientas de implementación continua para garantizar una implementación sin problemas. La monitorización constante del sistema nos permite identificar y abordar cualquier problema que pueda surgir en tiempo real, garantizando la disponibilidad y la confiabilidad del sistema para los usuarios finales. Así como la organización del proyecto en contenedores usando los servicios que nos proporciona Docker

## Ejemplo de Cambio Propuesto:
Imaginemos que se propone agregar una nueva opción de votación que permita a los usuarios asignar una nota a cada opción(del 1 al 10 por ejemplo). Esto implica cambios en la interfaz de usuario, lógica de votación y almacenamiento de datos así como postprocesado de los mismos. El proceso para abordar este cambio sería el siguiente:

### Diseño:
- Identificar requisitos específicos para la nueva funcionalidad.
- Crear diseños de interfaz de usuario que reflejen la opción de asignar notas a las respuestas.
- Crear una incidencia de tipo New Feature en la que se recoja de manera detallada tanto la lógica esperada como el diseño de la nueva funcionalidad realizado.

### Desarrollo:
- Creación de una rama feature para esta funcionalidad, la cual seguirá el formato feature/nuevaVotación.
- Implementar la lógica de votación con notas.
- Actualizar la base de datos para almacenar la información de los votos asociados a cada respuesta.

### Pruebas y Validación:
- Una vez creada la funcionalidad se realizarán las pruebas pertinentes guiándonos por las funciones CRUD, errores conocidos y en caso de que sea necesario, valores limite.
- Estas pruebas se automatizarán para garantizar la integridad de la nueva funcionalidad.
- Llevaremos a cabo pruebas manuales para evaluar la usabilidad y la experiencia del usuario a lo largo de todo el proceso.
- Una vez realizadas las pruebas, se cerrará la issue, o bien de manera manual o bien asociándola a la pull request la cual estará marcada por la aprobación tanto de GitHub Actions como de un integrante que la revisará.


## Preproducción:

- Una vez pasadas las pruebas y desplegado el proyecto, se analizará la cobertura reflejada en Codacy generando un informe de la misma. 
- Posteriormente probaremos la funcionalidad de la votación en un entorno controlado que simule el entorno de producción.

## Producción:

- Implementar la funcionalidad de la votación en el entorno de producción.
- Monitorear el sistema para detectar cualquier problema y realizar ajustes según sea necesario.

Este enfoque holístico en el desarrollo, desde el diseño hasta la implementación y más allá, nos ha permitido ofrecer un sistema de votación robusto y adaptable a medida que evolucionan los requisitos y las necesidades de los usuarios.



# Entorno de Desarrollo

1. **Visual Studio Code:**
   Visual Studio Code (VS Code) es el entorno de desarrollo integrado (IDE) seleccionado para la creación de la aplicación Django. Es un IDE ligero y potente que ofrece una amplia gama de extensiones para diferentes lenguajes de programación, incluido Python.

2. **Python 3.10:**
   La versión 3.10 de Python es la utilizada para el desarrollo de la aplicación. Python es el lenguaje de programación principal en el que se basa Django, y la versión 3.10 incluye nuevas características y mejoras.

## Librerías y Dependencias

Se han utilizado varias librerías y dependencias para el desarrollo de la aplicación, y se han especificado en el archivo `requirements.txt`. Aquí están las principales librerías junto con sus versiones correspondientes:

- **Django (4.1):**
  El framework web de alto nivel en Python que facilita el desarrollo rápido y limpio.

- **pycryptodome (3.15.0):**
  Una biblioteca de criptografía que proporciona implementaciones seguras de varios algoritmos criptográficos.

- **djangorestframework (3.14.0):**
  Una potente y flexible herramienta para construir APIs web.

- **django-cors-headers (3.13.0):**
  Una aplicación Django para manejar encabezados CORS (Cross-Origin Resource Sharing).

- **requests (2.28.1):**
  Una biblioteca HTTP para Python que facilita el envío de solicitudes HTTP.

- **django-filter (22.1):**
  Una aplicación de filtrado para Django.

- **psycopg2 (2.9.4):**
  Adaptador de base de datos PostgreSQL para Python.

- **coverage (6.5.0):**
  Una herramienta para medir la cobertura de código de Python.

- **jsonnet (0.18.0):**
  Un lenguaje de configuración de datos que permite la creación de archivos de configuración JSON de manera más concisa.

- **django-nose (1.4.6):**
  Integración de Nose para Django, una extensión de prueba.

- **django-rest-swagger (2.2.0):**
  Una interfaz gráfica para la documentación de API en Django REST Framework.

- **selenium (4.7.2):**
  Una herramienta para la automatización de navegadores web.

- **pynose (1.4.8):**
  Extiende pruebas unitarias y hace el testeo más fácil.

## Pasos para la Instalación

1. **Configurar Entorno Virtual:**
   Crea un entorno virtual para aislar las dependencias del proyecto.

```bash
python3.10 -m venv venv
source venv/bin/activate  # Para sistemas basados en Unix
```

2. **Configurar claves SSH con GitHub:**
   Generar claves: ssh-keygen -t rsa -b 4096
   Visualizar clave pública y copiar: cat id_rsa.pub
   Añadir la clave a GitHub

3. **Clonar el repositorio**
   Clona el repositorio de la aplicación Django desde GitHub:

   git clone https://github.com/part-pantoja/decide

4. **Instalar Dependencias:**
   Utiliza pip para instalar las dependencias del archivo requirements.txt.

   pip install -r requirements.txt

5. **Crear base de datos:**
   sudo su - postgres
   psql -c “create user decideuser with password ‘decidepass123’”
   psql -c “create database decidedb owner decideuser”

6. **Modificación de local_settings.py:**
   En el archivo local_settings.py nos aseguraremos que en el apartado DATABASES, los atributos ‘NAME’,‘USER’ y ‘PASSWORD’, tienen los valores de la base de datos creada previamente. También nos aseguraremos de que el atributo ‘HOST’ tiene el valor ‘localhost’.

7. **Aplicar Migraciones:**
   Aplica las migraciones de la base de datos para inicializarla.

   python manage.py makemigrations
   python manage.py migrate

8. **Crear Superusuario (Opcional):**
   Si es necesario, crea un superusuario para acceder al panel de administración de Django.

   python manage.py createsuperuser

9. **Ejecutar Servidor de Desarrollo:**
   Inicia el servidor de desarrollo de Django.

   python manage.py runserver
   La aplicación estará disponible en http://localhost:8000/.

Estos pasos aseguran la instalación adecuada de las dependencias y la configuración del entorno de desarrollo. Es importante tener en cuenta que estos pasos asumen un entorno Unix; si se utiliza un entorno diferente, los comandos pueden variar ligeramente.


# Propuesta de cambio: Modo claro/oscuro en interfaz

  

En primer lugar, deberemos crear una rama desde la versión más actualizada de nuestro proyecto.

  

Para ello, podemos hacer clic, desde nuestro repositorio GitHub, en **New Branch**, seleccionando dicha rama. La llamaremos `feature/LightDarkMode`.

  

Ahora crearemos la issue de la funcionalidad que queremos implementar. Para ello, haremos click en el menú Issue y seguidamente le daremos a New Issue.

  

Le pondremos nombre: **Nueva funcionalidad: LightDarkMode**. Asumo que su ID es 1.

  

Una vez hayamos creado la rama y la issue, iremos a nuestro IDE, en mi caso VSC, y escribiremos en consola:

  

```bash
git  fetch
```

Este comando nos proporciona todas las ramas del repositorio en la nube.

Ahora queremos saltar a la nueva rama. Usaremos el comando:
```bash
git checkout feature/LightDarkMode_
```
Comprobaremos con _git checkout_ nuevamente si hemos cambiado correctamente de rama.

Una vez en la rama, realizamos todos los cambios necesarios para cumplir con la funcionalidad.

El trabajo puede consistir en lo siguiente:

Crear dos base.html, de los cuales extenderán el resto de plantillas. Uno será light y otro dark. Dependiendo del valor de una variable, que se puede cambiar con un botón, se aplicará un base.html u otro.

Una vez realizados todos los cambios necesarios, usamos el siguiente comando para añadir las modificaciones al commit:
```bash
git  add .
```

Ahora procedemos a hacer el commit:
```bash
git commit -m “feat: LightDarkMode #1 
```

Por último, usamos git push origin master para actualizar el repositorio con este commit.

Por último, deberemos crear una pull request a la rama que interese, en mi caso develop, y asignar a algún compañero la revisión de esta.

Una vez aceptada, ya habremos implementado la funcionalidad.


# Conclusiones

En conclusión, partiendo de una base de código proporcionada por la asignatura y aprovechando el poder del framework Django, hemos logrado implementar mejoras significativas y nuevas funcionalidades para satisfacer los objetivos funcionales y técnicos establecidos. La introducción de tecnologías como Docker, Vagrant, PythonAnywhere, Codacy y GitHub Actions ha sido fundamental para el éxito del proyecto. La adopción de Docker y Vagrant ha simplificado la gestión de entornos de desarrollo y despliegue, permitiéndonos replicar y compartir fácilmente el sistema en diferentes contextos. La utilización de PythonAnywhere como plataforma de implementación en la nube ha facilitado el despliegue y la accesibilidad del sistema. La incorporación de Codacy para el análisis estático del código ha mejorado la calidad del mismo. La utilización de GitHub Actions ha automatizado tareas como pruebas, construcción y despliegue, mejorando la eficiencia del desarrollo y garantizando la estabilidad del código a lo largo del tiempo. 
En cuanto a las funcionalidades adicionales, la implementación de diferentes tipos de votaciones y una nueva forma de solicitar un censo y la mejora de la interfaz de usuario en la página de booth han enriquecido la experiencia del usuario y han hecho que el sistema sea más versátil.


# Trabajo futuro
## Listado de posibles tareas a desarrollar:

### Autenticación
- Autenticación por certificado digital
- Autenticación con Google
- Autenticación con OAuth

### Censo
- Importación y exportación de censo.
- Retirar censo desde frontend.
- Grupos de censo

### Votación
- Interfaz para crear nuevos tipos de votación.
- Interfaz para crear una Question.




